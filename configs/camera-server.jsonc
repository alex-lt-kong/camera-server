{
  "httpService": {
    "interface": "127.0.0.1",
    "port": 54321,
    "ssl": {
      "enabled": false,
      "keyPath": "",
      "pemPath": ""
    },
    /* Define a list of username:password key-value pairs here */
    "httpAuthentication": {
      "defaultUser": "defaultPassword"
    }
  },
  "devicesDefault": {
    "name": "Device-{{deviceIndex}}",
    "videoFeed": {
      "uri": "/dev/video{{deviceIndex}}",
      /* This will be directly passed to OpenCV. OpenCV will make it guess
      if left empty; otherwise, it is users responsibility
      to make sure the supplied parameter is correct/compatible with the
      video feed. Some methods to query supported fourcc:

      * For v4l2 device: v4l2-ctl --get-fmt-video --device <videoUri>
      * For RTSP device: use the IPCam's dashboard to check

      ./helper/opencv.py accompanied by the project can provide OpenCV's
      best guess, but this is not guaranteed to be the most accurate one.
      */
      "fourcc": "",
      /* an enum value of cv::VideoCaptureAPIs from here:
      https://docs.opencv.org/4.5.4/d4/d15/group__videoio__flags__base.html
      Typically one may try:
        cv::CAP_ANY = 0,
        cv::CAP_V4L = 200,
        cv::CAP_V4L2 = CAP_V4L,
        cv::CAP_GSTREAMER = 1800, 
        cv::CAP_FFMPEG = 1900,
        cv::CAP_OPENCV_MJPEG = 2200, 
      */
      "videoCaptureApi": 0
    },
    "frame": {
      /* Setting this to a lower value to limit CPU usage. For example,
      if the program can read 60 frames per sec from a deivce and
      throttleFpsIfHigherThan is set to 10, the program roughly discards
      5 in every 6 frames. Discarded frames are neither decompressed nor
      decoded, saving a lot of CPU resource. */
      "throttleFpsIfHigherThan": 10.0,
      /*
        cv::ROTATE_90_CLOCKWISE = 0,
        cv::ROTATE_180 = 1,
        cv::ROTATE_90_COUNTERCLOCKWISE = 2 
      Profiling shows that rotation is a pretty CPU intensive task,
      use with care! */
      "rotation": -1,
      "textOverlay": {
        /* By default, Camera Server writes some basic information, such as
        timestamp and device name, to each frame. Disable it if it is
        undesired. Profiling shows that putting text on frames is a
        CPU-intensive operation. */
        "enabled": true,
        "fontScale": 1.0
      },
      /* The below preferred values are directly sent to OpenCV. OpenCV (and
      its back-end) may or may not hornor our request. Note that these
      parameters do not control how frames are written to snapshot and saved
      to videos.*/
      "preferredInputWidth": -1,
      "preferredInputHeight": -1,
      "preferredFps": 30,
      /* The output frame dimensions are configured separately below. Leaving
      them to -1 means we output the frames in their original sizes. If input
      frame size (regardless the same as preferred size or not) and output
      frame settings are not consistent, frames will be resized. Profiling
      shows that frame resizing is a CPU-intensive task. Note that if input
      frames are rotated, outputWidth and outputHeight should match the input
      frame AFTER rotation to avoid resize. */
      "outputWidth": -1,
      "outputHeight": -1,
      /* Internally, frames are buffered in a FIFO queue. When performing motion
      detection, we use the last frame in the queue. When recording videos /
      preparing snapshots, we use the first frame in the queue. The idea
      is that we can "precapture" or notify the downstream program on
      an upcoming motion detection event, providing the video or the
      downstream program with some response time or some context. */
      "queueSize": 5
    },
    /* Apart from motion detection and video recording, Camera server
    supports another important feature: It provides downsteam data 
    uses (i.e., another program) with encoded JPEG image on a regular
    basis. This function is called "snapshot". Camera server supports
    a few common IPC method to share the JPEG image to other programs.*/
    "snapshot": {
      /* frameInterval is effective after frame.throttleFpsIfHigherThan is
      applied. For example, if throttleFpsIfHigherThan is set to 30, and
      frameInterval is set to 5, then the snapshot will be generated
      every 150 frames read from the source device. */
      "frameInterval": 600,
      "ipc": {
        "switch": {
          "http": true,
          /* Save the snapshot to filesystem. To achieve better performance,
          one may also enable RAM disk. */
          "file": true,
          /* Save the snapshot in POSIX shared memory with semaphore
          mechanism enabled */
          "sharedMem": true,
          /* Publush the snapshot with zeroMQ. */
          "zeroMQ": true
        },
        "file": {
          "path": "/tmp/snapshot-{{deviceIndex}}-{{deviceName}}-{{timestamp}}.jpg"
        },
        "http": {
          /* The path of HTTP request is not configurable, to access a
          device, users should always use:
          http(s)://interface:port/live_image/deviceId={{deviceIndex}} 
          where interface, port, etc are configured in the httpService
          section.*/
        },
        "sharedMem": {
          "semaphoreName": "/semaphore-device{{deviceIndex}}",
          /* man shm_open recommends that the name of a shared memory
          object should be , a null-terminated string of up to
          NAME_MAX (i.e., 255) characters consisting of an initial
          slash, followed by one or more characters, none of which
          are slashes.*/
          "sharedMemName": "/sharedMem-device{{deviceIndex}}",
          "sharedMemSize": 8388608 // 1024 * 8 * 1024 = 8MB
        },
        "zeroMQ": {
          "endpoint": "tcp://127.0.0.1:4242"
        }
      }
    },
    "motionDetection": {
      /* Valid values are:
      * 0, meaning "disabled": motion detection will NOT run and no video
      will be saved. The program will continue to provide snapshot function.
      * 1, meaning "detectMotion": motion detection will run and video will
      only be recorded if the following conditions are met. Events will be
      triggered.
      * 2, meaning "alwaysRecord": motion detection will NOT run and video
      will always be recorded. Events will be triggered.
      */
      "mode": 0,
      /* To conserve CPU resources, motion detection will only be
      performed on every Nth frame, instead of every frame. */
      "diffEveryNthFrame": 10,
      /* If the b/w value of the same pixel is changed by more than
      pixelDiffAbsThreshold, this pixel will be considered "changed"*/
      "pixelDiffAbsThreshold": 32,
      /* If the number of changed pixel divided by the total number
      of pixels are within the range of [frameDiffPercentageLowerLimit,
      frameDiffPercentageUpperLimit], the frame will be considered
      "changed". A changed frame will trigger motion detection. */
      "frameDiffPercentageLowerLimit": 1.0,
      "frameDiffPercentageUpperLimit": 50.0,
      // Useful for debug but CPU intensive
      "drawContours": false,
      "videoRecording": {
        "minFramesPerVideo": 240,
        "maxFramesPerVideo": 108000,
        /* Use to control the OpenCV's VideoWriter object*/
        "videoWriter": {
          /*
            * Set the format of the video being encoded, fourcc should be
            compatible with the extension in videoPath; otherwise it is up
            to OpenCV to decide how to reconcile them.
            * If a GPU is used, one needs to check if a given fourcc is
            supported by the GPU--it is possible that some formats are
            supported by OpenCV/FFmpeg but not supported by the GPU*/
          "fourcc": "x264",
          "fps": 30,
          "videoPath": "/tmp/{{deviceIndex}}-{{deviceName}}-{{timestampOnVideoStarts}}.mp4"
        }
      }
    },
    "events": {
      "onVideoStarts": [
        "/usr/bin/printf",
        "video starts at [{{timestampOnVideoStarts}}] %s",
        "!"
      ],
      "onVideoEnds": [
        "/usr/bin/echo",
        "onVideoEnds echoed from device [{{deviceIndex}}]"
      ],
      "onDeviceOffline": [
        "/usr/bin/echo",
        "Device [{{deviceIndex}}] is offline at [{{timestampOnDeviceOffline}}]"
      ],
      "onDeviceBackOnline": [
        "/usr/bin/echo",
        "Device [{{deviceName}}] is back online"
      ]
    }
  },
  "devices": [
    /* A pair of braces ({}) means we have one device, but we want
    to leave all the settings to default. To use custom settings,
    duplicate the corresponding devicesDefault section and assgin
    new values*/
    {}
  ]
}
